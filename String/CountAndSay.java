package String;

/**
 * LeetCode 38: Count and Say
 *
 * Idea:
 * -----
 * Each term is generated by reading the previous term.
 * This is essentially Run-Length Encoding (RLE).
 *
 * Example:
 * "1211" → one 1, one 2, two 1s → "111221"
 *
 * Time Complexity:
 * ----------------
 * O(total characters generated) → optimal (output-bound problem)
 *
 * Space Complexity:
 * -----------------
 * O(length of current term)
 */

public class CountAndSay {

    /**
     * Encodes a string using Run-Length Encoding.
     *
     * Example:
     * Input: "1211"
     * Output: "111221"
     */
    private String encode(String s) {

        StringBuilder sb = new StringBuilder();

        // Previous character we are counting
        char prev = s.charAt(0);
        int count = 1;

        // Start from index 1 because first character is already counted
        for (int i = 1; i < s.length(); i++) {
            char curr = s.charAt(i);

            if (curr == prev) {
                // Same character → increase count
                count++;
            } else {
                // Different character → flush previous group
                sb.append(count).append(prev);

                // Reset for new character
                prev = curr;
                count = 1;
            }
        }

        // Append the last character group
        sb.append(count).append(prev);

        return sb.toString();
    }

    /**
     * Generates the nth term of the Count and Say sequence.
     */
    public String countAndSay(int n) {

        // Base case
        String result = "1";

        // Build sequence iteratively
        for (int i = 1; i < n; i++) {
            result = encode(result);
        }

        return result;
    }

    public static void main(String[] args) {
        CountAndSay cs = new CountAndSay();
        int n = 5;
        System.out.println("The " + n + "th term of the Count and Say sequence is: " + cs.countAndSay(n));
    }

}
